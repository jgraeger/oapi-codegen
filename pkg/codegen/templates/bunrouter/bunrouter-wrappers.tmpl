// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
    Handler ServerInterface
    HandlerMiddlewares []MiddlewareFunc
    ErrorHandlerFunc func(w http.ResponseWriter, r bunrouter.Request, err error)
}

type MiddlewareFunc func(bunrouter.HandlerFunc) bunrouter.HandlerFunc

{{range .}}{{$opid := .OperationId}}

// {{$opid}} operation middleware
func (siw *ServerInterfaceWrapper) {{$opid}}(w http.ResponseWriter, r bunrouter.Request) error {
    ctx := r.Context()
    var err error
{{range .PathParams}}// ------------- Path parameter "{{.ParamName}}" -------------
    var {{$varName := .GoVariableName}}{{$varName}} {{.TypeDef}}
{{if .IsPassThrough}}
    {{$varName}} = r.Param("{{.ParamName}}")
{{end}}
{{if .IsJson}}
    err = json.Unmarshal([]byte(r.Param("{{.ParamName}}")), &{{$varName}})
    if err != nil {
        return &UnmarshallingParamError{ParamName: "{{.ParamName}}", Err: err}
    }
{{end}}
{{if .IsStyled}}
    err = runtime.BindStyledParameterWithLocation("{{.Style}}",{{.Explode}}, "{{.ParamName}}", runtime.ParamLocationPath, r.Param("{{.ParamName}}"), &{{$varName}})
    if err != nil {
        return &InvalidParamFormatError{ParamName: "{{.ParamName}}", Err: err}
    }
{{end}}
{{end}}

{{range .SecurityDefinitions}}
    ctx = context.WithValue(ctx, {{.ProviderName | sanitizeGoIdentity | ucFirst}}Scopes, {{toStringArray .Scopes}})
{{end}}

{{if .RequiresParamObject}}
    // Parameter object where we will unmarshal all parameters from the context
    var params {{.OperationId}}Params
{{range $paramIdx, $param := .QueryParams}}
    {{- if (or (or .Required .IsPassThrough) (or .IsJson .IsStyled)) -}}
    // ------------- {{if .Required}}Required{{else}}Optional{{end}} query parameter "{{.ParamName}}" -------------
    {{end}}
    {{if (or (or .Required .IsPassThrough) .IsJson)}}
    if paramValue := r.URL.Query().Get("{{.ParamName}}"); paramValue != "" {
        {{if .IsPassThrough}}
        params.{{.GoName}} = {{if not .Required}}&{{end}}paramValue
        {{end}}
        {{if .IsJson}}
        var value {{.TypeDef}}
        err = json.Unmarshal([]byte(paramValue), &value)
        if err != nil {
            return &UnmarshallingParamError{ParamName: "{{.ParamName}}", Err: err}
        }

        params.{{.GoName}} = {{if not .Required}}&{{end}}value
        {{end}}
    }{{if .Required}} else {
        return &RequiredParamError{ParamName: "{{.ParamName}}"}
    }{{end}}
    {{end}}
    {{if .IsStyled}}
    err = runtime.BindQueryParameter("{{.Style}}", {{.Explode}}, {{.Required}}, "{{.ParamName}}", r.URL.Query(), &params.{{.GoName}})
    if err != nil {
    return &InvalidParamFormatError{ParamName: "{{.ParamName}}", Err: err}
    }
    {{end}}
{{end}}

{{if .HeaderParams}}
    headers := r.Header
{{range .HeaderParams}}// ------------- {{if .Required}}Required{{else}}Optional{{end}} header parameter "{{.ParamName}}" -------------
    if valueList, found := headers[http.CanonicalHeaderKey("{{.ParamName}}")]; found {
        var {{.GoName}} {{.TypeDef}}
        n := len(valueList)
        if n != 1 {
            return &TooManyValuesForParamError{ParamName: "{{.ParamName}}", Count: n}
        }

        {{if .IsPassThrough}}
        params.{{.GoName}} = {{if not .Required}}&{{end}}valueList[0]
        {{end}}

        {{if .IsJson}}
        err = json.Unmarshal([]byte(valueList[0]), &{{.GoName}})
        if err != nil {
            return &UnmarshallingParamError{ParamName: "{{.ParamName}}", Err: err}
        }
        {{end}}

        {{if .IsStyled}}
        err = runtime.BindStyledParameterWithLocation("{{.Style}}",{{.Explode}}, "{{.ParamName}}", runtime.ParamLocationHeader, valueList[0], &{{.GoName}})
        if err != nil {
            return &InvalidParamFormatError{ParamName: "{{.ParamName}}", Err: err}
        }
        {{end}}

        params.{{.GoName}} = {{if not .Required}}&{{end}}{{.GoName}}
    }{{if .Required}} else {
        return &RequiredHeaderError{
            ParamName: "{{.ParamName}}",
            Err: fmt.Errorf("header parameter {{.ParamName}} is required, but not found"),
        }
    }{{end}}
{{end}}
{{end}}

{{range .CookieParams}}
    var cookie *http.Cookie

    if cookie, err := r.Cookie("{{.ParamName}}"); err != nil {
        {{if .IsPassThrough}}
        params.{{.GoName}} = {{if not .Required}}&{{end}}cookie.Value
        {{end}}
        {{if .IsJson}}
        var value {{.TypeDef}}
        var decoded string
        decoded, err := url.QueryUnescape(cookie.Value)
        if err != nil {
            return &UnescapedCookieParamError{ParamName: "{{.ParamName}}", Err: err}
        }

        err = json.Unmarshal([]byte(decoded), &value)
        if err != nil {
            return &UnmarshallingParamError{ParamName: "{{.ParamName}}", Err: err}
        }

        params.{{.GoName}} = {{if not .Required}}&{{end}}value
        {{end}}
        {{if .IsStyled}}
        var value {{.TypeDef}}
        err = runtime.BindStyledParameterWithLocation("simple",{{.Explode}}, "{{.ParamName}}", runtime.ParamLocationCookie, cookie.Value, &value)
        if err != nil {
            return &InvalidParamFormatError{ParamName: "{{.ParamName}}", Err: err}
        }
        params.{{.GoName}} = {{if not .Required}}&{{end}}value
        {{end}}
    }{{if .Required}} else {
        return &RequiredParamError{
            ParamName: "{{.ParamName}}",
            Err: fmt.Errorf("cookie argument {{.ParamName}} is required, but not found"),
        }
    }{{end}}
{{end}}
{{end}}

    err = siw.Handler.{{.OperationId}}(w, r.WithContext(ctx){{genParamNames .PathParams}}{{if .RequiresParamObject}}, params{{end}})
    return err
}

{{end}}

type UnescapedCookieParamError struct {
    ParamName string
    Err error
}

func (e *UnescapedCookieParamError) Error() string {
    return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
    return e.Err
}

type UnmarshallingParamError struct {
    ParamName string
    Err error
}

func (e *UnmarshallingParamError) Error() string {
    return fmt.Sprintf("Error unmarshalling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshallingParamError) Unwrap() error {
    return e.Err
}

type RequiredParamError struct {
    ParamName string
}

func (e *RequiredParamError) Error() string {
    return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
    ParamName string
    Err error
}

func (e *RequiredHeaderError) Error() string {
    return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
    return e.Err
}

type InvalidParamFormatError struct {
    ParamName string
	  Err error
}

func (e *InvalidParamFormatError) Error() string {
    return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
    return e.Err
}

type TooManyValuesForParamError struct {
    ParamName string
    Count int
}

func (e *TooManyValuesForParamError) Error() string {
    return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}